C++ Day 1: Environment setup and Hello World

Configured MinGW, VS Code, and verified compilation on Windows 11. Implemented basic I/O and main return logic.

C++ Fundamentals: Modular Design & System Architecture (1/27/26)
1. The 3-Stage Compilation Pipeline
Understanding the journey from source code to executable is vital for debugging.

Preprocessing: Handles directives starting with #. (e.g., #include copies the library code into your file).

Compiling: Translates C++ into machine-readable object code. This is where syntax errors are caught.

Linking: The "Glue" stage. Connects your object files with external libraries (like iostream) to create the final .exe.

2. Headers vs. Implementation
Moving toward Modularity and Information Hiding:

Header File (.h): The Contract. Contains declarations (what the function looks like). Uses #pragma once to prevent multiple inclusions.

Source File (.cpp): The Implementation. Contains the actual logic (how the function works).

Main Driver: A separate file containing int main() that "instigates" the logic.

3. Namespaces: "Good Fences Make Good Neighbors"
Namespaces prevent Naming Collisions in collaborative environments.

The Problem: Two libraries use the same name (e.g., sort()).

The Solution: Use Qualified Names with the scope resolution operator ::.

Example: std::cout vs my_library::cout.

Best Practice: Avoid using namespace std;. Being explicit with std:: makes code readable, narrows down errors, and prevents "Namespace Pollution."